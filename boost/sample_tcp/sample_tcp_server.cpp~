#include <cstdlib>
#include <iostream>
#include <boost/asio.hpp>

using boost::asio::ip::tcp;

class session : public std::enable_shared_from_this<session>
{
public:
    session(boost::asio::io_service& io_service, std::vector<std::shared_ptr<session>>& sp_v)
        : socket_(io_service), sp_v_(sp_v)
    {
    }

    tcp::socket& socket() {
        return socket_;
    }

    void start()
    {
        socket_.async_read_some(boost::asio::buffer(data_, max_length),
                                [&, self = shared_from_this()]
                                (const boost::system::error_code& e, std::size_t s) {
                                    handle_read(e, s);
                                });
    }

    void handle_read(const boost::system::error_code& error,
                     std::size_t bytes_transferred) {
        if (!error) {
            std::string data = "connect client: " + std::to_string(sp_v_.size());
            std::cout << "data: " << data << std::endl;
            boost::asio::async_write(socket_,
                                     boost::asio::buffer(data),
                                     [&, self = shared_from_this()]
                                     (const boost::system::error_code& e,
                                      std::size_t s) {
                                         handle_write(e, s);
                                     });
        }
        else {
            if (error == boost::asio::error::eof) {
            }
            else {
                std::cout << "handle_read error!" << error.message() << std::endl;
            }

            //session delete
            for(auto itr = sp_v_.begin(); itr != sp_v_.end(); ++itr) {
                if (itr->get() == this) { // itr->get() = &*(*itr)
                    std::cout << "do sp_v_.erace()" << std::endl;
                    sp_v_.erase(itr);
                    return;
                }
            }
        }
    }

    void handle_write(const boost::system::error_code& error,
                      std::size_t bytes_transferred) {
        if (!error)
        {
            socket_.async_read_some(boost::asio::buffer(data_, max_length),
                                    [&, self = shared_from_this()]
                                    (const boost::system::error_code& e, std::size_t s) {
                                        handle_read(e, s);
                                    });
        }
        else {
            std::cout << "handle_write error!" << error.message() << std::endl;

            //session delete
            for(auto itr = sp_v_.begin(); itr != sp_v_.end(); ++itr) {
                if (itr->get() == this) { // itr->get() = &*(*itr)
                    std::cout << "do sp_v_.erace()" << std::endl;
                    sp_v_.erase(itr);
                    return;
                }
            }
        }
    }

private:
    tcp::socket socket_;
    enum { max_length = 1024 };
    char data_[max_length];
    std::vector<std::shared_ptr<session>>& sp_v_;
};

class server
{
public:
    server(boost::asio::io_service& io_service)
        : io_service_(io_service),
          acceptor_(io_service,
                    tcp::endpoint(boost::asio::ip::address::from_string("127.0.0.1"), 31400)) {
        std::shared_ptr<session> session_ptr = std::make_shared<session>(io_service_, sp_v_);

        acceptor_.async_accept(session_ptr->socket(),
                               [&, session_ptr]
                               (const boost::system::error_code& e) {
                                   handle_accept(session_ptr, e);
                               });
    }

    void handle_accept(std::shared_ptr<session> const& session_ptr,
                       boost::system::error_code const& error) {
        if (!error) {
            sp_v_.push_back(session_ptr);
            session_ptr->start();
            std::cout << "connect client: " << sp_v_.size() << std::endl;
            std::shared_ptr<session> session_ptr2 = std::make_shared<session>(io_service_, sp_v_);
            acceptor_.async_accept(session_ptr2->socket(),
                                   [&, session_ptr2]
                                   (const boost::system::error_code& e) {
                                       handle_accept(session_ptr2, e);
                                   });
        }
        else {
            std::cout << "accept error!" << std::endl;
        }
    }

    std::vector<std::shared_ptr<session>> sp_v_;

private:
    boost::asio::io_service& io_service_;
    tcp::acceptor acceptor_;

};

int main() {
    boost::asio::io_service io_service;

    server s(io_service);

    io_service.run();

    return 0;
}
